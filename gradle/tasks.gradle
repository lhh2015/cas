import org.gradle.internal.logging.*
import org.gradle.internal.logging.events.*

import java.util.regex.Matcher
import java.util.regex.Pattern

tasks.withType(Javadoc) {
    def exceptions = []
    doFirst {
        gradle.services.get(LoggingOutputInternal).addOutputEventListener(new OutputEventListener() {
            void onOutput(OutputEvent event) {
                if (event.toString() =~ " warning: ") {
                    exceptions << new GradleException("Javadoc warning: ${event.toString()}")
                }
            }
        })
    }
    doLast {
        exceptions.each {
            throw it
        }
    }
}

task pathingJar(type: Jar, description: "Produces a 'pathing' JAR whose manifest class-path contains project runtime dependencies") {
    dependsOn configurations.runtime
    appendix = "pathing"

    doFirst {
        manifest {
            attributes "Class-Path":
                    configurations.runtime.files.collect {
                        it.toURL().toString().replaceFirst("/file:/+/", "/")
                    }
                    .join(" ")
        }
    }
}

task testJar(type: Jar, dependsOn: testClasses, description: "archive the testClasses") {
    baseName = "${project.archivesBaseName}-tests"
    classifier = "tests"
    from sourceSets.test.output
}

task sourcesJar(type: Jar, dependsOn: classes) {
    classifier = "sources"
    from sourceSets.main.allSource
}

task resourcesJar(type: Jar) {
    classifier "resources"
    from project.file("src/main/resources")
}

task javadocJar(type: Jar, dependsOn: javadoc) {
    classifier = "javadoc"
    from javadoc.destinationDir
}

task cleanLogs(description: "Clean build log files") {
    delete fileTree(dir: project.projectDir, includes: ["**/*.log", "**/*.gz", "**/*.log.gz"])
}

task spotbugs(type: FindBugs, description: "Set up classpath for Findbugs") {
    pluginClasspath = project.configurations.spotbugsPlugins
}

task showConfiguration {
    doLast() {
        def cfg = project.hasProperty("configuration") ? project.property("configuration") : "compile"
        configurations.getByName(cfg).each { println it }
    }
}

task downloadDependencies {
    description "Pre-download project dependencies for all configurations"
    doLast {
        configurations.getAsMap().each { name, config ->
            logger.info "Retrieving dependencies for $project:$name"
            try {
                config.files
            } catch (e) {
                project.logger.info e.message
            }
        }
    }
}

gradle.buildFinished { buildResult ->
    cleanLogs
}

clean.dependsOn("cleanLogs")

/**
 * Execute Checkstyle on all modified files
 * from: https://ebaytech.berlin/checkstyle-on-changed-files-with-gradle-1619e49dbe4e
 *
 * Use for new style changes whwere we do not want to make the full codebasw compliant immediately.
 */
if (!Boolean.getBoolean("skipCheckstyle")) {
    task checkstyleNewRules(type: Checkstyle) {
        def changedFiles = getChangedFiles()
        include changedFiles
        configFile new File(rootDir, "style/checkstyle-rules.xml")
        configProperties = ["checkstyle.suppressions.file": new File(rootDir, "style/checkstyle-suppressions.xml")]
        ignoreFailures false
        showViolations true
    }
    tasks.check.dependsOn checkstyleNewRules
}

/**
 * Get all files that are changed but not deleted nor renamed.
 * Compares to master or the specified target branch.
 *
 * @return list of all changed files
 */
def getChangedFiles() {
    // Get the target and source branch
    def ghprbTargetBranch = System.getenv("ghprbTargetBranch")
    def ghprbSourceBranch = System.getenv("ghprbSourceBranch")

    // Compare to master if no branch specified
    def targetBranch = ghprbTargetBranch ? "origin/${ghprbTargetBranch}" : "master"
    def sourceBranch = ghprbSourceBranch ? "origin/${ghprbSourceBranch}" : ""

    // Get list of all changed files including status
    def systemOutStream = new ByteArrayOutputStream()
    def command = "git diff --name-status --diff-filter=dr $targetBranch $sourceBranch"
    command.execute().waitForProcessOutput(systemOutStream, System.err)
    def allFiles = systemOutStream.toString().trim().split('\n')
    systemOutStream.close()

    // Remove the status prefix
    Pattern statusPattern = Pattern.compile("(\\w)\\t+(.+)")
    List<String> files = new ArrayList<>()
    for (file in allFiles) {
        Matcher matcher = statusPattern.matcher(file)
        if (matcher.find()) {
            files.add(matcher.group(2))
        }
    }

    // Return the list of touched files
    files
}
